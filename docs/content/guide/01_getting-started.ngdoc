@ngdoc overview
@name Getting Started
@description

# Getting Started

### Setup HTML
To get started, embed angular-translate and the package for its default
interpolation in your HTML document. Of course, this should happen
**after** Angular itself is embedded. Your HTML should look something like this:

<pre>
<html>
  <head>
    <meta charset="utf-8">
    <title>i18n app</title>

    <script src="path/to/angular.js"></script>
    <script src="path/to/angular-translate.js"></script>
    <script src="path/to/angular-translate-interpolation-default.js"></script>
    <script src="app.js"></script>
  </head>

  <body ng-app="myApp">

  </body>
</html>
</pre>

### Declaring dependencies
Once this is done, you can declare angular-translate as dependency of your app.
Angular provides dependency injection, which is awesome. So, to tell your app
that it needs angular-translate to work properly, simply inject
angular-translate as dependency into your module like shown in the following code.
This gives you access to all components angular-translate comes with.

<pre>
var app = angular.module('myApp', ['pascalprecht.translate']);
</pre>

### Introducing `$translateProvider`

angular-translate is now declared as dependency, which means we now have access
to all of its components. Angular follows a pretty straight forward architecture
when it comes to configuration of different services you might want to use later
in your app. Just take a look at the following code.

Pretty sure, you've already seen something like this:

<pre>
app.config(function ($locationProvider) {
  $locationProvider.html5Mode(true);
});
</pre>

Or maybe the configuration of a `$route` service:

<pre>
app.config(function ($routeProvider) {
  $routeProvider.when('/something', {
    templateUrl: 'url/to/template',
    controller: 'SomeFancyCtrl'
  });
});
</pre>

So what actually happens here is not the _use of a certain service_ to configure
some things. Its more the _configuration of a certain service_ using a
_provider_, which happens to be used later in your app. This means,
`$locationProvider.html5Mode(true)` configures the `$location` **service** to
work with html5 mode. So if a service should be configurable from outside,
it needs a corresponding provider that provides the interface you need.

angular-translate comes with a `$translateProvider` that you can use to
configure the provided `$translate` service which  handles the i18n stuff in your
app. The `$translate` service is used by directives and filters you can use
through your whole application. To let `$translate` service translate your
contents, it has to know, which translations are actually available.

This is where `$translateProvider` comes in. `$translateProvider` provides
methods to teach your app different languages and let `$translate` service
make use of them.

### Teaching your app a language

Teaching your app a language with `$translateProvider` is very easy. First you
have to inject the provider into your modules configuration function (which is
the only place where you can access it).

<pre>
app.config(function ['$translateProvider', ($translateProvider) {

}]);
</pre>

Now, to add a language, you have to make `$translateProvider` know of a
**translation table**. What does that mean? It's actually quite simple.
angular-translate expects translation tables as JSON objects. So all you have
to do, is to represent your translation data as JavaScript hash object, or,
when loading remotely, as a JSON object. This is how a translation table could
look like:

```json
{
  "TRANSLATION_ID": "This is a concrete translation for a specific language."
}
```

Is that easy? The translation table above contains just one translation. As you
can see, the key represents a translation id, where as the value represents
the concrete translation for certain language. You don't even have to provide
any information in your translation table, to which language it corresponds. But
more on that later.

Let's add a translation table to our app. `$translateProvider` provides a
method called `translations()`, which takes care of that. Let's say we have a
translation table like this:

<pre>
var translations = {
  HEADLINE: 'What an awesome module!',
  PARAGRAPH: 'Srsly!'
};
</pre>

We can add this table with the use of `$translateProvider.translations()`:

<pre>
app.config(function ['$translateProvider', ($translateProvider) {
  // add translation table
  $translateProvider.translations(translations);
}]);
</pre>

This is basically all you have to do. Since we're adding the translation table
at configuration time, `$translate` service is able to access it, once it is
instantiated and used. Here's the working code:

<doc:example module="myApp">
  <doc:source>
    <script>
      var translations = {
        HEADLINE: 'What an awesome module!',
        PARAGRAPH: 'Srsly!'
      };

      var app = angular.module('myApp', ['pascalprecht.translate']);

      app.config(function ['$translateProvider', ($translateProvider) {
        // add translation table
        $translateProvider.translations(translations);
      }]);
    </script>
    <div>
      <h1>Nothing to see here yet!</h1>
      <p>But we'll change it now</p>
    </div>
  </doc:source>
</doc:example>

Yous app is now ready to be localized! In the next chapter, you'll learn how to
use the provided directive and filter by angular-translate, to interpolate 
your translations.

### Using $translate service

<code>angular-translate</code> provides several ways to translate certain contents of
your app. One way is to use the provided <code>$translate</code> service directly.
You actually wouldn't use this approach, because you don't want to bind your apps
controllers and services too hard to your translated content. But just to show that
it's possible.

Simply inject the <code>$translate</code> service as you would do with others.

<pre>
angular.module('myApp').controller('Ctrl', ['$translate', '$scope', function ($translate, $scope) {

  $scope.translatedText = $translate('HEADLINE_TEXT');

}]);
</pre>

This service in actually beeing used module-wide in <code>angular-translate</code> to
translate translation id's. If you want to know what behavior you can expect from
<code>$translate</code> in specific cases, check out the [related tests](https://github.com/PascalPrecht/angular-translate/blob/master/test/unit/translateSpec.js#L40-L60).

**[&rarr; View Plunker](http://plnkr.co/edit/D68BxJ)**

### Using translate filter

Most of the time you want to translate contents at view layer, since this is the place
where your contents are. This decouples the translate logic from your controllers and
services. <code>angular-translate</code> comes with a **filter** and a **directive** to
translate your contents.

You make use of <code>translateFilter</code> as follows:

<pre>
<h1>{{'HEADLINE_TEXT' | translate}}</h1>
<p>{{'SOME_TEXT' | translate}}</p>
</pre>

Pretty easy ha? And again, there is a [testsuite](https://github.com/PascalPrecht/angular-translate/blob/master/test/unit/translateSpec.js#L310-L326)
which shows you how <code>translateFilter</code> behaves in certain cases.

**[&rarr; View Plunker](http://plnkr.co/edit/UUEmtf)**

### Using translate directive

Using <code>translateFilter</code> is great, but using <code>translateDirective</code> is better.
It turned out that having too many filters in a view sets up too many watch expressions,
which is why <code>angular-translate</code> also provides a directive to translate your
contents in view layer.

You can use <code>translateDirective</code> in many different ways, here is one possible
way:

<pre>
<h1 translate>HEADLINE_TEXT</h1>
<p translate>SOME_TEXT</p>
</pre>

You can also pass translation id's as attribute values:

<pre>
<h1 translate="HEADLINE_TEXT"></h1>
<p translate="SOME_TEXT"></p>
</pre>

And there is [so much more possible](https://github.com/PascalPrecht/angular-translate/blob/master/test/unit/translateDirectiveSpec.js)!

**[&rarr; View Plunker](http://plnkr.co/edit/6of2GK)**
